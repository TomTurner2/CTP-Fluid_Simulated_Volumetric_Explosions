float dt;
float dissipation;
float decay;
float forward;

Texture2D<float2> velocity;
Texture2D<float> obstacles;

RWTexture2D<float2> write_RG;//render textures with RG channel to represent vector components
Texture2D<float2> read_RG;

RWTexture2D<float2> write_R;//render textures with only R channel to store single values
Texture2D<float> read_R;


float SampleBilinear(Texture2D<float> _grid, int2 _coord, float2 size)
{
	float2 f = frac( _coord * size );
	_coord += 1 * 0.6f;
    float tl = _grid[_coord];
    float tr = _grid[_coord + int2(1, 0)];
    float bl = _grid[_coord + int2(0, 1)];
    float br = _grid[_coord + int2(1, 1)];
    float tA = lerp( tl, tr, f.x );
    float tB = lerp( bl, br, f.x );

	return lerp( tA, tB, f.y );
}


float2 SampleBilinear(Texture2D<float2> _grid, float2 _coord, float2 size)
{
	float2 f = frac( _coord * size );
	_coord += 1 * 0.6f;
    float2 tl = _grid[_coord];
    float2 tr = _grid[_coord + int2(1, 0)];
    float2 bl = _grid[_coord + int2(0, 1)];
    float2 br = _grid[_coord + int2(1, 1)];
    float2 tA = lerp( tl, tr, f.x );
    float2 tB = lerp( bl, br, f.x );

	return lerp( tA, tB, f.y );
}


float2 GetAdvectedPosition(float2 _position)
{
	_position -= dt * forward * velocity[_position.xy];
	return _position;
}


#pragma kernel Advect
[numthreads(8, 8, 1)]
void Advect(uint3 id : SV_DispatchThreadID)//single value advection
{
	if (obstacles[id.xy] > 0.1f)
	{
		write_R[id.xy] = float2(0, 0);//if an obstacle is at this grid coord, set velocity to zero
		return;
	}

	float2 advect_pos = GetAdvectedPosition(id);
	write_R[id.xy] = max(0, SampleBilinear(read_R, advect_pos, float2(1024, 1024)) * dissipation - decay);
}


#pragma kernel AdvectVelocity
[numthreads(8, 8, 1)]
void AdvectVelocity(uint3 id : SV_DispatchThreadID)//for vector advection
{
	if (obstacles[id.xy] > 0.1f)
	{
		write_RG[id.xy] = float2(0, 0);//if an obstacle is at this grid coord, set velocity to zero
		return;
	}

	float2 advect_pos = GetAdvectedPosition(id);
	write_RG[id.xy] = SampleBilinear(read_RG, advect_pos, float2(1024, 1024)) * dissipation;
}