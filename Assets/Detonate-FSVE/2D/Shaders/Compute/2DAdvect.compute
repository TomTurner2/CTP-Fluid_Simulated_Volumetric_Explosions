#define THREAD_COUNT = 8;

float dt;
float dissipation;
float decay;
float forward;

RWTexture2D<float2> velocity;
RWTexture2D<float2> obstacles;

RWTexture2D<float2> write_RG;//render textures with RG channel to represent vector components
RWTexture2D<float2> read_RG;

RWTexture2D<float2> write_R;//render textures with only R channel to store single values
RWTexture2D<float2> read_R;


float2 GetAdvectedPosition(float3 _position)
{
	_position -= dt * forward * velocity[_position.xy];
	return _position;
}


#pragma kernel AdvectVelocity
[numthreads(THREAD_COUNT, THREAD_COUNT, 1)]
void AdvectVelocity(uint3 id : SV_DispatchThreadID)//for vector advection
{
	if (obstacles[id.xy] > 0.1f)
	{
		write_RG[id.xy] = float2(0, 0);//if an obstacle is at this grid coord, set velocity to zero
		return;
	}

	float2 advect_pos = GetAdvectedPosition(id);
	//render tex has bilinear filtering enabled so I can directly write the value and get smooth results
	write_RG[id.xy] = max(0, read_RG[id.xy] *advect_pos * dissipation - decay);
}


#pragma kernel Advect
[numthreads(THREAD_COUNT, THREAD_COUNT, 1)]
void Advect(uint3 id : SV_DispatchThreadID)//single value advection
{
	if (obstacles[id.xy] > 0.1f)
	{
		write_R[id.xy] = float2(0, 0);//if an obstacle is at this grid coord, set velocity to zero
		return;
	}

	float2 advect_pos = GetAdvectedPosition(id);
	write_R[id.xy] = max(0, read_R[id.xy] * advect_pos * dissipation - decay);
}
