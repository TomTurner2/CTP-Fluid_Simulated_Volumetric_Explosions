RWTexture2D<float2> write_RG;
RWTexture2D<float2> velocity;
RWTexture2D<float> obstacles;

float2 CheckSolidCells(float _obstacles, float2 _velocity)
{
	if (_obstacles >  0.1f)//if solid
		return float2(0,0);//velocity is zero

	return _velocity;
}

#pragma kernel Divergence
[numthreads(8,8,1)]
void Divergence (uint3 id : SV_DispatchThreadID)
{
	//get cell neighbours velocity
	float2 velocity_north = velocity[id.xy + float2(0, 1)].xy;
	float2 velocity_south = velocity[id.xy + float2(0, -1)].xy;
	float2 velocity_east = velocity[id.xy + float2(1, 0)].xy;
	float2 velocity_west = velocity[id.xy + float2(-1, 0)].xy;

	//get cell neighbours obstacles
	float obstacles_north = obstacles[id.xy + float2(0, 1)].x;
	float obstacles_south = obstacles[id.xy + float2(0, -1)].x;
	float obstacles_east = obstacles[id.xy + float2(1, 0)].x;
	float obstacles_west = obstacles[id.xy + float2(-1, 0)].x;

	//set any solid cells to zero velocity
	velocity_north = CheckSolidCells(obstacles_north, velocity_north);
	velocity_south = CheckSolidCells(obstacles_south, velocity_south);
	velocity_east = CheckSolidCells(obstacles_east, velocity_east);
	velocity_west = CheckSolidCells(obstacles_west, velocity_west);

	float divergence = 0.5f * (velocity_east.x - velocity_west.x +
	velocity_north.y - velocity_south.y);

	write_RG[id.xy] = float2(divergence, 0);
}
