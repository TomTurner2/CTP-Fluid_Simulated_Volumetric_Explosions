#pragma kernel Boundary


float4 size;
RWStructuredBuffer<float> write_R;
float4 sphere_position;
float sphere_radius;


int GetIndex(int3 _id, float4 _size)
{
	return _id.x + _id.y * _size.x + _id.z * _size.x * _size.y;
}


[numthreads(8,8,8)]
void Boundary(uint3 id : SV_DispatchThreadID)
{
	float obstacle = 0;

	//if at edge add an obstacle
	if (id.x - 1  <= 0)	
	{ 
		obstacle = 1;
	}

	if (id.x + 1 > (uint)size.x - 1)
	{ 
		obstacle = 1;
	}

	if (id.y - 1 <= 0)
	{ 
		obstacle = 1;
	}

	if (id.y + 1 > (uint)size.y - 1)
	{ 
		obstacle = 1;
	}

	if (id.z - 1 <= 0)
	{ 
		obstacle = 1;
	
	}

	if (id.z + 1 > (uint)size.z - 1)	
	{ 
		obstacle = 1;
	}

	write_R[GetIndex(id, size)] = obstacle;
}


#pragma kernel AddSphereObstacle
[numthreads(8,8,8)]
void AddSphereObstacle(uint3 id : SV_DispatchThreadID)
{
	float3 pos = id / (size.xyz - 1.0f) - sphere_position.xyz;//need to take into account simulation scaling
	float magnitude = pos.x * pos.x + pos.y * pos.y + pos.z * pos.z;

	float radius_percent = sphere_radius * 0.1f;//sphere collider conversion to grid
	float radius_squared = radius_percent * radius_percent;

	float amount = exp(-magnitude/radius_squared);
	amount = step(0.01f, amount);//if greater than or equal 0.01f, set obstacle to 1

	int index = GetIndex(id, size);
	write_R[index] = write_R[index] + amount;//for some reason this has no effect, might need two grids for obstacle?
}
