#pragma kernel Divergence

RWStructuredBuffer<float3> write_RGB;
StructuredBuffer<float3> velocity;
StructuredBuffer<float> obstacles;
float4 size;

int GetIndex(int3 _id, float4 _size)
{
	return _id.x + _id.y * _size.x + _id.z * _size.x * _size.y;
}


float3 CheckSolidCells(float _obstacles, float3 _velocity)
{
	if (_obstacles >  0.1f)//if solid
		return float3(0, 0, 0);//velocity is zero

	return _velocity;
}


[numthreads(8,8,8)]
void Divergence (uint3 id : SV_DispatchThreadID)
{
	int index = GetIndex(id, size); 

	//get neighbour indexs
	int up_id =  id.x + min(size.y - 1, id.y + 1)*size.x + id.z*size.x*size.y;
	int down_id =  id.x + max(0, id.y-1)*size.x + id.z*size.x*size.y;

	int left_id =  max(0, id.x-1) + id.y*size.x + id.z*size.x*size.y;
	int right_id =  min(size.x-1, id.x+1) + id.y*size.x + id.z*size.x*size.y;

	int front_id = id.x + id.y*size.x + max(0, id.z-1)*size.x*size.y;
	int back_id = id.x + id.y*size.x + min(size.z-1, id.z+1)*size.x*size.y;

	//get cell neighbours velocity
	float3 velocity_up = velocity[up_id];
	float3 velocity_down = velocity[down_id];

	float3 velocity_left = velocity[left_id];
	float3 velocity_right = velocity[right_id];

	float3 velocity_front = velocity[front_id];
	float3 velocity_back = velocity[back_id];

	//get cell neighbours obstacles
	float obstacles_up = obstacles[up_id];
	float obstacles_down = obstacles[down_id];
	float obstacles_right = obstacles[right_id];
	float obstacles_left = obstacles[left_id];
	float obstacles_forward = obstacles[front_id];
	float obstacles_back = obstacles[back_id];

	//set any solid cells to zero velocity
	velocity_up = CheckSolidCells(obstacles_up, velocity_up);
	velocity_down = CheckSolidCells(obstacles_down, velocity_down);
	velocity_right= CheckSolidCells(obstacles_right, velocity_right);
	velocity_left = CheckSolidCells(obstacles_left, velocity_left);
	velocity_front = CheckSolidCells(obstacles_forward, velocity_front);
	velocity_back = CheckSolidCells(obstacles_back, velocity_back);

	float divergence = 0.5f * ((velocity_right.x - velocity_left.x) +
	(velocity_up.y - velocity_down.y) + (velocity_back.z - velocity_front.z));

	write_RGB[index] = float3(divergence, 0, 0);
}
