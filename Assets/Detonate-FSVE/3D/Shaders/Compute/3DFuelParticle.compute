float dt;
float particle_drag;
float particle_radius;
float thermal_mass;
float burn_rate;
float burn_threshold;
float produced_heat;
float divergence_amount;
float4 size;

struct FuelParticle//CPU struct maps to this one
{
	float3 position;
	float3 velocity;
	float temperature;
	float mass;
	float soot_accumulation;
};

RWStructuredBuffer<FuelParticle> particles;
StructuredBuffer<float3> velocity;
StructuredBuffer<float> temperature;
StructuredBuffer<float> divergence;


int GetIndex(int3 _id, float4 _size)
{
	return _id.x + _id.y * _size.x + _id.z * _size.x * _size.y;
}


// CG includes are fairly broken in Unity, so duped code :/
float SampleBilinear(StructuredBuffer<float> _grid, float3 _coord, float4 size)
{
	int x = _coord.x;
	int y = _coord.y;
	int z = _coord.z;
	
	float fx = _coord.x-x;
	float fy = _coord.y-y;
	float fz = _coord.z-z;
	
	//only want to validate once
	int x_plus_one = min(size.x-1, x+1);
	int y_plus_one = min(size.y-1, y+1);
	int z_plus_one = min(size.z-1, z+1);
	
	float x0 = _grid[GetIndex(_coord, size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y, z), size)] * fx;
	float x1 = _grid[GetIndex(int3(x, y, z_plus_one), size)] *
	(1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y, z_plus_one), size)] * fx;	
	float x2 = _grid[GetIndex(int3(x, y_plus_one, z), size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y_plus_one, z), size)] * fx;
	float x3 = _grid[GetIndex(int3(x, y_plus_one, z_plus_one), size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y_plus_one, z_plus_one), size)] * fx;
	
	float z0 = x0 * (1.0f-fz) + x1 * fz;
	float z1 = x2 * (1.0f-fz) + x3 * fz;
	
	return z0 * (1.0f-fy) + z1 * fy;
}


float3 SampleBilinear(StructuredBuffer<float3> _grid, float3 _coord, float4 size)
{
	int x = _coord.x;
	int y = _coord.y;
	int z = _coord.z;
	
	float fx = _coord.x-x;
	float fy = _coord.y-y;
	float fz = _coord.z-z;
	
	//only need to validate once
	int x_plus_one = min(size.x-1, x+1);
	int y_plus_one = min(size.y-1, y+1);
	int z_plus_one = min(size.z-1, z+1);
	
	float3 x0 = _grid[GetIndex(_coord, size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y, z), size)] * fx;
	float3 x1 = _grid[GetIndex(int3(x, y, z_plus_one), size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y, z_plus_one), size)] * fx;	
	float3 x2 = _grid[GetIndex(int3(x, y_plus_one, z), size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y_plus_one, z), size)] * fx;
	float3 x3 = _grid[GetIndex(int3(x, y_plus_one, z_plus_one), size)] * (1.0f-fx) + _grid[GetIndex(int3(x_plus_one, y_plus_one, z_plus_one), size)] * fx;
	
	float3 z0 = x0 * (1.0f-fz) + x1 * fz;
	float3 z1 = x2 * (1.0f-fz) + x3 * fz;
	
	return z0 * (1.0f-fy) + z1 * fy;
}


#pragma kernel ApplyParticlesVelocities
[numthreads(8,1,1)]
void ApplyParticlesVelocities (uint3 id : SV_DispatchThreadID)
{
	float3 velocity = particles[id.x].velocity;	
	particles[id.x].position += velocity * dt;
}


bool CheckVelocityDifference(float _velocity, float _dt, float _velocity_diff)
{
	return abs(_velocity) < _dt * _velocity_diff;
}


#pragma kernel CalculateParticlesVelocity
[numthreads(8,1,1)]
void CalculateParticlesVelocity(uint3 id : SV_DispatchThreadID)
{

	float3 grid_pos =  particles[id.x].position.xyz * size.xyz;
	float3 fluid_velocity = SampleBilinear(velocity, grid_pos, size);

	if(particles[id.x].mass > 0.001f)
	{
		float3 velocity_diff = fluid_velocity - particles[id.x].velocity;
		float total_drag = particle_drag * particle_radius * particle_radius;// Drag according to particle size
		float3 final_velocity = dt * (1.0f/particles[id.x].mass) * total_drag * velocity_diff;

		if (CheckVelocityDifference(final_velocity.x, dt, velocity_diff.x) &&
			CheckVelocityDifference(final_velocity.y, dt, velocity_diff.y) &&
			CheckVelocityDifference(final_velocity.z, dt, velocity_diff.z))
		{
			particles[id.x].velocity += final_velocity;
		}
		else// Velocity change should not be larger than difference between fluid and particl velocity
		{
			particles[id.x].velocity = fluid_velocity;
		}
	}
	else
	{
		particles[id.x].velocity = fluid_velocity;
	}

	particles[id.x].temperature += dt * (SampleBilinear(temperature, grid_pos, size) -
	particles[id.x].temperature) / thermal_mass;// Apply fluid temperature to particle according to thermal mass
}


#pragma kernel BurnParticle
[numthreads(8,1,1)]
void BurnParticle(uint3 id : SV_DispatchThreadID)
{
	if (particles[id.x].temperature < burn_threshold)// Don't burn if not hot enough
		return;

	float3 grid_pos =  particles[id.x].position.xyz * size.xyz;// Particles position in volume
	temperature[grid_pos] += dt * produced_heat * burn_rate;// Add temperature to fluid
	divergence[grid_pos] += dt * divergence_amount * burn_rate;// Add Divergence
	particles[id.x] -= dt * burn_rate;// Burn off mass from the particle
}
