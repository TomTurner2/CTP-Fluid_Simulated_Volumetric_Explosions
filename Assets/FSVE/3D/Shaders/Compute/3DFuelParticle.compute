float dt;
float particle_drag;
float particle_radius;
float thermal_mass;
float burn_rate;
float burn_threshold;
float produced_heat;
float divergence_amount;
float4 size;

struct FuelParticle// CPU struct maps to this one
{
	float3 position;
	float3 velocity;
	float temperature;
	float mass;
};

RWStructuredBuffer<FuelParticle> particles;
StructuredBuffer<float3> velocity;
StructuredBuffer<float> temperature;

RWStructuredBuffer<float> divergence;
RWStructuredBuffer<float> temperature_write;


int GetIndex(int3 _id, float4 _size)
{
	return _id.x + _id.y * _size.x + _id.z * _size.x * _size.y;
}


// CG includes are fairly broken in Unity, so duped code :/
float SampleBilinear(StructuredBuffer<float> _grid, float3 _coord, float4 size)
{
	int x = _coord.x;
	int y = _coord.y;
	int z = _coord.z;
	
	float weight_x = _coord.x-x;
	float weight_y = _coord.y-y;
	float weight_z = _coord.z-z;
	
	// Only want to validate once
	int x_plus_one = min(size.x-1, x+1);
	int y_plus_one = min(size.y-1, y+1);
	int z_plus_one = min(size.z-1, z+1);
	
	// Get neighbouring corner cells and lerp between them
	float x0 = lerp(_grid[GetIndex(_coord, size)], _grid[GetIndex(int3(x_plus_one, y, z), size)], weight_x);
	float x1 = lerp(_grid[GetIndex(int3(x, y, z_plus_one), size)], _grid[GetIndex(int3(x_plus_one, y, z_plus_one), size)], weight_x);	
	float x2 = lerp(_grid[GetIndex(int3(x, y_plus_one, z), size)], _grid[GetIndex(int3(x_plus_one, y_plus_one, z), size)], weight_x);
	float x3 = lerp(_grid[GetIndex(int3(x, y_plus_one, z_plus_one), size)], _grid[GetIndex(int3(x_plus_one, y_plus_one, z_plus_one), size)], weight_x);
	
	float z0 = lerp(x0, x1, weight_z);// Lerp the lerps
	float z1 = lerp(x2, x3, weight_z);
	
	return lerp(z0, z1, weight_y);// Lerp the lerped lerps
}


// Really wish I could template this, rather duplicating the same function and changing only the buffer type 
float3 SampleBilinear(StructuredBuffer<float3> _grid, float3 _coord, float4 size)
{
	int x = _coord.x;
	int y = _coord.y;
	int z = _coord.z;
	
	float weight_x = _coord.x-x;
	float weight_y = _coord.y-y;
	float weight_z = _coord.z-z;
	
	// Only want to validate once
	int x_plus_one = min(size.x-1, x+1);
	int y_plus_one = min(size.y-1, y+1);
	int z_plus_one = min(size.z-1, z+1);
	
	// Get neighbouring corner cells and lerp between them
	float3 x0 = lerp(_grid[GetIndex(_coord, size)], _grid[GetIndex(int3(x_plus_one, y, z), size)], weight_x);
	float3 x1 = lerp(_grid[GetIndex(int3(x, y, z_plus_one), size)], _grid[GetIndex(int3(x_plus_one, y, z_plus_one), size)], weight_x);	
	float3 x2 = lerp(_grid[GetIndex(int3(x, y_plus_one, z), size)], _grid[GetIndex(int3(x_plus_one, y_plus_one, z), size)], weight_x);
	float3 x3 = lerp(_grid[GetIndex(int3(x, y_plus_one, z_plus_one), size)], _grid[GetIndex(int3(x_plus_one, y_plus_one, z_plus_one), size)], weight_x);

	float3 z0 = lerp(x0, x1, weight_z);// Lerp the lerps
	float3 z1 = lerp(x2, x3, weight_z);
	
	return lerp(z0, z1, weight_y);// Lerp the lerped lerps
}


#pragma kernel ApplyParticlesVelocities
[numthreads(8,1,1)]
void ApplyParticlesVelocities (uint3 id : SV_DispatchThreadID)
{
	float3 velocity = particles[id.x].velocity;	
	particles[id.x].position += velocity * dt;// Move acording to velocity
}


bool CheckVelocityDifference(float _velocity, float _dt, float _velocity_diff)
{
	return abs(_velocity) < _dt * _velocity_diff;// Velocity change should not be larger than difference between fluid and particle velocity
}


bool CheckVelocityDifferences(float3 _final_velocity, float _dt, float3 _velocity_diff)
{
	return CheckVelocityDifference(_final_velocity.x, _dt, _velocity_diff.x) &&
			CheckVelocityDifference(_final_velocity.y, _dt, _velocity_diff.y) &&
			CheckVelocityDifference(_final_velocity.z, _dt, _velocity_diff.z);
}


#pragma kernel CalculateParticlesVelocity
[numthreads(8,1,1)]
void CalculateParticlesVelocity(uint3 id : SV_DispatchThreadID)
{
	float3 grid_pos =  particles[id.x].position.xyz * size.xyz;
	float3 fluid_velocity = SampleBilinear(velocity, grid_pos, size);

	if (particles[id.x].mass > 0.001f)
	{
		float3 velocity_diff = fluid_velocity - particles[id.x].velocity;
		float total_drag = particle_drag * particle_radius * particle_radius;// Drag according to particle size
		float3 final_velocity = dt * (1.0f / particles[id.x].mass) * total_drag * velocity_diff;// Final velocity according to mass and drag

		if (CheckVelocityDifferences(final_velocity, dt, velocity_diff))
		{
			particles[id.x].velocity += final_velocity;// Add on new velocity
		}
		else
		{
			particles[id.x].velocity = fluid_velocity;// Set new velocity, if larger than diff between fluid and prev velocity
		}
	}
	else
	{
		particles[id.x].velocity = fluid_velocity;// If no mass just go with the flow
	}

	particles[id.x].temperature += dt * (SampleBilinear(temperature, grid_pos, size) -
	particles[id.x].temperature) / thermal_mass;// Apply fluid temperature to particle according to thermal mass
}


#pragma kernel BurnParticle
[numthreads(8,1,1)]
void BurnParticle(uint3 id : SV_DispatchThreadID)
{
	if (particles[id.x].temperature < burn_threshold &&
	particles[id.x].mass > 0.001f)// Don't burn if not hot enough
		return;

	float3 grid_pos =  particles[id.x].position.xyz * size.xyz;// Particles position in volume
	int index = GetIndex(grid_pos, size);

	temperature_write[index] += dt * produced_heat * burn_rate;// Add temperature to fluid
	divergence[index] += dt * divergence_amount * burn_rate;// Add Divergence
	particles[id.x].mass -= dt * burn_rate;// Burn off mass from the particle
}
